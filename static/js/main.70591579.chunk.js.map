{"version":3,"sources":["logo.svg","components/cell.jsx","components/clue.jsx","components/clues.jsx","components/game.jsx","App.js","reportWebVitals.js","index.js"],"names":["Cell","props","cell","x","y","solution","number","solved","type","functions","cellToWords","cellToClue","fillCell","checkCells","toggleSolved","toggleHighlightClue","useState","text","setText","className","id","onFocusCapture","e","console","log","onBlur","onChange","value","currentTarget","toUpperCase","length","words","check1","check2","Clue","clue","direction","word","highlighted","Clues","clues","across","filter","down","clueToWord","map","idx","Game","cells","setCells","setClues","setWords","useEffect","fetch","headers","then","res","json","data","forEach","convertWordToCells","i","push","convertXYtoIdx","j","split","num","Number","str","join","newCells","onOff","wordId","find","obj","App","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.70591579.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import React, {useState, useEffect} from \"react\";\n\nexport default function Cell(props) {\n    const {x,y,solution, number, type, solved} = props.cell\n    const {cellToClue, cellToWords, fillCell, checkCells, toggleSolved, toggleHighlightClue} = props.functions\n    const [text, setText] = useState(\"\")\n\n    const handleChange = (e) => {\n        const value = e.currentTarget.value.toUpperCase()\n        if (value.length <= 1) {\n            setText(value)\n            fillCell(x,y,value) \n            const words = cellToWords(x,y)\n            const check1 = checkCells(words[0])\n            const check2 = checkCells(words[1])\n            if (check1) toggleSolved(words[0], true,x,y);\n            if (check2) toggleSolved(words[1], true,x,y);\n            if (!(check1 || check2)) {\n                toggleSolved(words[0], false, x,y)\n                toggleSolved(words[1], false, x,y)\n            };\n         } else return;\n    };\n\n    const handleFocus = e => {\n        toggleHighlightClue(number, true)\n        console.log(\"focus\")\n    }\n\n    // const handleClick = e => {\n    //     toggleHighlightClue(number, true)\n    // }\n\n    const handleBlur = e => {\n        toggleHighlightClue(number, false)\n        console.log(\"blur\")\n    }\n    \n    return(\n            solution ? \n            <div className={`cell ${solved ? \"solved\" : false}`}id={`${x},${y}`}>\n                <div className=\"cell-number\">\n                    {number} \n                </div>\n                <input className=\"cell-letter\" \n                onFocusCapture={handleFocus}\n                onBlur={handleBlur} \n                onChange={handleChange} value={text}>\n                </input>\n            </div> :\n            <div className=\"cell-black\"></div>\n    )\n}    \n","import React from \"react\";\n\nexport default function Clue(props) {\n    const {direction, text, word, number, highlighted} = props.clue\n    return(\n        <div className={highlighted?`clue highlighted`:`clue`} id={`clue${number}`}>\n            <span className=\"number\">{number}</span>\n            <span className=\"text\">{text}</span>\n        </div>\n    )\n}","import React, {useState, useEffect} from \"react\";\nimport Clue from \"./clue\";\n\nexport default function Clues(props) {\n    const {clues} = props\n    const across = clues.filter(clue => clue.direction === 0)\n    const down = clues.filter(clue => clue.direction === 1)\n    const {clueToWord} = props.functions\n\n    return(\n        <div className=\"clues-container\">\n            <div className=\"across\">\n                <h2 className=\"clues-header\">Across</h2>\n                {across.map((clue, idx) => <Clue key={idx} clue={clue} />)}\n            </div>\n            <div className=\"down\">\n                <h2 className=\"clues-header\">Down</h2>\n                {down.map((clue, idx) => <Clue key={idx} clue={clue} />)}\n            </div>\n        </div>\n    )\n}","import React, {useState, useEffect} from \"react\";\nimport Cell from \"./cell\";\nimport Clues from \"./clues\";\n// useEffect is similar to componentDidMount\n// pass [] as second argument to useEffect to make it only run once\n\nexport default function Game() {\n    const [cells, setCells] = useState([])\n    const [clues, setClues] = useState([])\n    const [words, setWords] = useState([])\n\n    const getData = () => {\n        fetch('crossword-puzzle.json', {\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json'\n            } \n        })\n        .then(res => res.json())\n        .then(data => {\n            data.words.forEach(word => {\n                const idx = convertWordToCells(word)\n                // add index of all related squares to word object\n                word.cells = idx\n                for (const i of idx) {\n                // add word object to all related indices\n                !data.cells[i].word ? data.cells[i].word = [word] : data.cells[i].word.push(word)\n            }\n        })\n        setClues(data.clues)\n        setCells(data.cells)\n        setWords(data.words)\n        });\n    }\n\n    useEffect(() => getData(), []);\n\n    const cellToClue = (number) => { \n        const clueArr = clues.filter(clue => clue.number === number)\n        return clueArr;\n    }\n\n    const clueToWord = (wordId) => {\n        const word = words.find(obj => obj.id == wordId)\n        return word; \n    }\n\n    // finds the word based on x,y of cell\n    const cellToWords = (x,y) => {\n        return cells[convertXYtoIdx(x,y)].word\n    }\n    \n    //converts x,y grid coordinates to an indice in cells array\n    const convertXYtoIdx = (x,y) => 15*(y-1)+(x-1);\n    \n    //converts the coordinates of a word into an array of indices\n    const convertWordToCells = word => {\n        let x = word.x.split(\"-\").map(num => Number(num))\n        let y = word.y.split(\"-\").map(num => Number(num))\n        \n        const idx = []\n        let i,j; \n        if (x.length > 1) {\n            [i, j]= [x[0], x[1]]\n            while (i <= j) {\n                idx.push(convertXYtoIdx(i, y))\n                i++\n            }\n        } else {\n            [i,j] = [y[0], y[1]]\n            while (i <= j) {\n                idx.push(convertXYtoIdx(x, i))\n                i++\n            }\n        }\n        return idx;\n    }\n    \n\n    // sets the \"value\" of a cell for use in checkCells(word)\n    const fillCell = (x,y, value) => {\n        cells[convertXYtoIdx(x,y)].value = value\n    }\n    \n    // check if every cell of word is filled and correct\n    const checkCells = word => {\n        const str = [] \n        word.cells.forEach(i => {\n            if (!cells[i].value) cells[i].value = \" \";\n            str.push(cells[i].value)\n        })\n        \n        if (str.join(\"\") == word.solution) {\n            return true;\n        } else {\n            return false\n        };\n    }\n\n    // highlights or unhighlights tiles depending on if word is solved\n    const toggleSolved = (word, solved, x, y) => {\n        let newCells = [...cells]\n        const idx = convertXYtoIdx(x,y)\n        word.cells.forEach(i => {\n            if (newCells[i].solved) {\n                const check1 = checkCells(newCells[i].word[0])\n                const check2 = checkCells(newCells[i].word[1])\n                if (!( check1 || check2)) newCells[i].solved = solved;\n            } else newCells[i].solved = solved;\n        })\n        setCells(newCells)\n    }\n\n    // highlight clue when clicking a numbered cell\n    const toggleHighlightClue = (number, onOff) => {\n        const clueArr = cellToClue(number) \n        clueArr.forEach(clue => clue.highlighted = onOff)\n        setClues([...clues])\n    }\n\n    return(\n        <div className=\"game-container\">\n            <div className=\"grid\">\n                {cells.map((cell, i) => <Cell key={`${i}`} functions={{cellToClue, cellToWords, fillCell, checkCells, toggleSolved, toggleHighlightClue}} cell={cell}/>)}\n            </div>\n\n            {clues.length > 0 ?\n            <Clues key={clues.length} functions={{clueToWord}} clues={clues} /> :\n            null \n            }\n\n        </div>\n    )\n\n}","import logo from './logo.svg';\nimport Game from \"./components/game\";\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <Game /> \n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}